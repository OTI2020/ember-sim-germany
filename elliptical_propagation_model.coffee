# TODO #17 - calculation of the propagation model should come from the user interface, maybe as JSON?
# this function is the elliptical spread model

calculate_arrival_time = (from_point, to_point, flat) ->
  # t0, t1, flat) {  // time input is not used by that way
  if flat == null
    flat = false
  # also for less typing
  xp = to_point.x
  yp = to_point.y
  x0 = from_point.x
  y0 = from_point.y
  xd = xp - x0
  yd = yp - y0
  slope = 1
  # test data //TODO #18
  # TODO: use a better approximation for slope - there's some empirical exp() stuff somewhere
  terrain_factor = 2.0 * slope / 10.0
  # based on firefighter's mannual - spread rate doubles for every 10 degrees of slope
  # theta = from_point.theta
  # aspect points in the direction of the downslope, need to rotate by 180
  aspect = if flat == true then 180.0 else 1 + 180
  # from_point.param('ASPECT') + 180.0; // TODO #18
  terrain_theta = aspect * Math.PI / 180.0
  # after [Alexander 1985]
  wind_speed = document.getElementById('windSpeed').value
  # (from_point.param('WIND', 'speed_2m'));
  wind_factor = 1.0 + 0.00120 * wind_speed ** 2.154
  wind_theta = document.getElementById('windDirection').value
  # ((from_point.param('WIND', 'angle') * Math.PI) / 180.0) + Math.PI;
  tx = terrain_factor * Math.cos(terrain_theta)
  ty = terrain_factor * Math.sin(terrain_theta)
  wx = wind_factor * Math.cos(wind_theta)
  wy = wind_factor * Math.sin(wind_theta)
  cx = tx + wx
  cy = ty + wy
  c = Math.sqrt(cx ** 2 + cy ** 2)
  theta = Math.atan(cy / cx) - (Math.PI / 2.0)
  theta = if cx > 0 then (if cy > 0 then theta else theta + 2 * Math.PI) else theta + Math.PI
  # spread rate is in km/h, we need m/h
  r = simple_spread_rate_model() * 1000.0 / 60.0
  #
  #let r = 0.5 // TEST data 
  # TODO HACK - this is to correct the ellipsis shape for high winds - need to find the problem with the algorithm! // this comment is from Australia
  r = r / (-0.0097 * wind_speed + 1.0558)
  forward_spread_rate = r
  # spread rate models include wind effects, so we'll approximate the flanking (0-wind) spread rate
  flanking_spread_rate = r / wind_factor
  # for less typing...
  c = Math.cos(theta)
  s = Math.sin(theta)
  b = flanking_spread_rate
  bsq = b ** 2
  # calculate focus distance
  f = (forward_spread_rate ** 2 - bsq) / (2 * forward_spread_rate)
  fsq = f ** 2
  # calculate major axis length from forward spread rate and focus
  a = forward_spread_rate - f
  asq = a ** 2
  # transform the coordinate system
  xs = xd * c + yd * s
  ys = -xd * s + yd * c
  # solve quadratic equation
  div = 1 - (fsq / asq)
  p2 = 2 * xs * f / asq / (2 * div)
  q = -(xs ** 2 / asq + ys ** 2 / bsq) / div
  tarrival = -p2 + Math.sqrt(p2 ** 2 - q)
  # the second solution of the quadratic equation is physically irrelevant as it inverts the ellipsis
  # t2 = - p2 - Math.sqrt( p2**2 - q )
  # calculate slope between the two points
  #TODO #18
  # const phi = Math.atan((to_point.param('ELEVATION') - from_point.param('ELEVATION')) / Math.sqrt(Math.pow(xd, 2) + Math.pow(yd, 2)));
  phi = Math.atan((3 - 2) / Math.sqrt(xd ** 2 + yd ** 2))
  # test data for elevation - must be changed
  #tarrival = tarrival * (0.9+Math.random()*0.2)
  # correct for slope and initial ignition time
  tarrival = tarrival / Math.cos(phi)
  tarrival = from_point.t + tarrival
  console.log 'tarrival: ' + tarrival
  tarrival

# ---
# generated by js2coffee 2.2.0