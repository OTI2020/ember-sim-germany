// Generated by CoffeeScript 1.12.7
(function() {
  var EllipticalPropagationModel, PropagationModel,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.Models || (window.Models = {});

  window.Models.PropagationModel = PropagationModel = (function() {
    function PropagationModel() {}

    return PropagationModel;

  })();

  window.Models.EllipticalPropagationModel = EllipticalPropagationModel = (function(superClass) {
    extend(EllipticalPropagationModel, superClass);

    function EllipticalPropagationModel() {
      return EllipticalPropagationModel.__super__.constructor.apply(this, arguments);
    }

    EllipticalPropagationModel.prototype.calculate_arrival_time = function(from_point, to_point, t0, t1, flat) {
      var a, aspect, asq, b, bsq, c, cx, cy, div, f, flanking_spread_rate, forward_spread_rate, fsq, p2, phi, q, r, s, slope, tarrival, terrain_factor, terrain_theta, theta, tx, ty, wind_factor, wind_speed, wind_theta, wx, wy, x0, xd, xp, xs, y0, yd, yp, ys;
      if (flat == null) {
        flat = false;
      }
      if (from_point.position.x === to_point.position.x && from_point.position.y === to_point.position.y) {
        return from_point.ignition_time;
      }
      xp = to_point.position.x;
      yp = to_point.position.y;
      x0 = from_point.position.x;
      y0 = from_point.position.y;
      xd = xp - x0;
      yd = yp - y0;
      slope = flat === true ? 0 : from_point.param('SLOPE');
      if (slope == null) {
        return;
      }
      terrain_factor = 2.0 * slope / 10.0;
      aspect = flat === true ? 180.0 : from_point.param('ASPECT') + 180.0;
      terrain_theta = aspect * Math.PI / 180.0;
      wind_speed = from_point.param('WIND', 'speed_2m');
      wind_factor = 1.0 + 0.00120 * Math.pow(wind_speed, 2.154);
      wind_theta = from_point.param('WIND', 'angle') * Math.PI / 180.0 + Math.PI;
      tx = terrain_factor * Math.cos(terrain_theta);
      ty = terrain_factor * Math.sin(terrain_theta);
      wx = wind_factor * Math.cos(wind_theta);
      wy = wind_factor * Math.sin(wind_theta);
      cx = tx + wx;
      cy = ty + wy;
      c = Math.sqrt(Math.pow(cx, 2) + Math.pow(cy, 2));
      theta = Math.atan(cy / cx) - Math.PI / 2.0;
      theta = cx > 0 ? cy > 0 ? theta : theta + 2 * Math.PI : theta + Math.PI;
      r = from_point.spread_rate * 1000.0 / 60.0;
      r = r / (-0.0097 * wind_speed + 1.0558);
      forward_spread_rate = r;
      flanking_spread_rate = r / wind_factor;
      c = Math.cos(theta);
      s = Math.sin(theta);
      b = flanking_spread_rate;
      bsq = Math.pow(b, 2);
      f = (Math.pow(forward_spread_rate, 2) - bsq) / (2 * forward_spread_rate);
      fsq = Math.pow(f, 2);
      a = forward_spread_rate - f;
      asq = Math.pow(a, 2);
      xs = xd * c + yd * s;
      ys = -xd * s + yd * c;
      div = 1 - (fsq / asq);
      p2 = ((2 * xs * f) / asq) / (2 * div);
      q = -(Math.pow(xs, 2) / asq + Math.pow(ys, 2) / bsq) / div;
      tarrival = -p2 + Math.sqrt(Math.pow(p2, 2) - q);
      phi = Math.atan((to_point.param('ELEVATION') - from_point.param('ELEVATION')) / Math.sqrt(Math.pow(xd, 2) + Math.pow(yd, 2)));
      tarrival = tarrival / Math.cos(phi);
      tarrival = from_point.ignition_time + tarrival;
      return tarrival;
    };
    console.log("EllipticalPropagationModel: " + EllipticalPropagationModel);


    return EllipticalPropagationModel;

  })(PropagationModel);

}).call(this);
console.log("Very End of File propagation_model.js");